<!doctype html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<link type="text/css" rel="stylesheet" href="topics.css">
		<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
		<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>

	<body>
		<div class="TitleText">
			Recursion
		</div>
		<hr><br>
		<div class="SubtitleText">
			1.1 Real World Problem
		</div>
		<div class="ContentText">
			Let's solve this question.
			<br><br>
			<i>Modified from Project Euler No. 14</i>
			<br>
			The following iterative sequence is defined for the set of positive integers:
			<br>
			<p>\[n → n/2 \: (n \: is \: even)\]\[n → 3n + 1 \: (n \: is \: odd)\]</p>
			Using the rule above and starting with 13, we generate the following sequence:
			<br><br>
			<center>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</center>
			<br>
			It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
			<br><br>
			Which starting number, under one hundred, produces the longest chain?
			<br><br>
			NOTE: Once the chain starts the terms are allowed to go above one million. [Answer : 97]
			<br><br>
			I would expect you to do something like this :
			<pre><code class="Java">public static int getChainCount (long n) {
	int chainCount=1; //the number itself
	while (n!=1) { //ends at 1
		chainCount++;
		if (n%2==0) { //n is even
			n=n/2;
		} else { //n is odd
			n=3*n+1;
		}
	}
	return chainCount;
}
	
public static void main (String [] args) {
	int longestChain=1;
	for (int i=1;i&#60;100;i++) {
		int chainCount=getChainCount(i);
		if (chainCount>=longestChain) {
			longestChain=chainCount;
			startingNumWithLongestChain=i;
			//set the variable to largest number if exist.
		}
	}
	System.out.println(longestChain);
}</code></pre>
		</div>
		<br><hr><br>
		<div class="SubtitleText">
			1.2 The Recursion
		</div>
		<div class="ContentText">
			Recursion is the a way of writing the code such that it calls itself. In our context, we can change the method to call itself. It is composed by the following elements :
			<ul>
				<li>Calling the originating method itself directly, or indirectly.</li>
				<li>Stopping condition</li>
			</ul>
			This is the opposite of of iterative (loop). The performance is worse than iterative, due to extra processing time needed to handle the method calling internally. However, in problems that are naturally recursive, like the problem we did earlier, recursive method can help us to solve it with less line of code than iterative way.
			<pre><code class="Java">public static int getChainCount (long n) {
	if (n==1) return 1; //Stop calling itself recursively.
	else
	 	//Expects the next recursive method to stop for us.
		if (n%2==0) return getChainCount(n/2)+1;
		else return getChainCount(3*n+1)+1;
	}
}
	
public static void main (String [] args) {
	int longestChain=1;
	for (int i=1;i&#60;100;i++) {
		int chainCount=getChainCount(i);
		if (chainCount>=longestChain) {
			longestChain=chainCount;
			startingNumWithLongestChain=i;
			//set the variable to largest number if exist.
		}
	}
	System.out.println(longestChain);
}
</code></pre>
		</div>
		<br><hr><br>
		<div class="SubtitleText">
			1.3 Fibonacci Number
		</div>
		<div class="ContentText">
			Fibonacci Number is defined as follow :
			<p>\[f(n) = f(n-2) + f(n-1)\]</p>
			The first & (zeroth) Fibonacci number are 1. Now, write a program that displays the 30<sup>th</sup> Fibonacci Number. With loop, you could have done this:
			<pre><code class="Java">public static int getFn(int n) {
	int fNMinus1=1;
	int fNMinus2=1;
	int fN=2;
	for (int i=2;i&#60;30;i++) {
		fNMinus2=fNMinus1;
		fNMinus1=fN;
		fN=fNMinus1+fNMinus2;
	}
	return fN;
}</code></pre>
			But with recursion, you can do it like this:
			<pre><code class="Java">public static int getFn(int n) {
	if (n<=1) return 1; //Stop calling itself recursively
	else return getFn(n-1)+getFn(n-2);
}</code></pre>
			Isn't that look way better than the iterative approach? :)
		</div>
	</body>
</html>